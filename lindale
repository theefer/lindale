#!/usr/bin/ruby

require 'Qt4'
require 'xmmsclient/async'

require './xmmsclient-qt4'


# TODO:
# - use columns to separate fields
# - type in playlist to filter playlist entries (custom search)
# - actions should report a status message
# - reuse search results (activate to play, enqueue, copy, etc)


class Xmms2Cache < Qt::Object

  signals 'metadata_received(int)', 'status_updated(int, int)', 'position_updated(int, int)',
          'playlist_refreshed()', 'playlist_entry_inserted(int, int)',
          'playlist_entry_removed(int)'

  attr_reader :playback_status, :playlist_position, :playlist_entries

  def initialize(conn)
    super()

    @xc = conn
  end

  def init_playback_status()
    unless defined?(@playback_status)
      @playback_status = nil
      @xc.playback_status.notifier(&method(:listen_status))
      @xc.broadcast_playback_status.notifier(&method(:listen_status))
    end
  end

  def init_playlist_position()
    unless defined?(@playlist_position)
      @playlist_position = nil
      @xc.playlist.current_pos.notifier(&method(:listen_position))
      @xc.broadcast_playlist_current_pos.notifier(&method(:listen_position))
    end
  end

  def init_playlist_entries()
    unless defined?(@playlist_entries)
      @playlist_entries = nil
      @xc.playlist.entries.notifier(&method(:listen_playlist_entries))
      @xc.broadcast_playlist_changed.notifier(&method(:listen_playlist_changes))
    end
  end

  def has_mediainfos?(id)
    @mediainfos = Hash.new unless defined?(@mediainfos)
    return @mediainfos.key?(id)
  end

  def fetch_mediainfos(id)
    return @mediainfos[id] if has_mediainfos?(id)

    @mediainfos[id] = nil
    @xc.medialib_get_info(id) do |dict|
      @mediainfos[id] = dict.value
      emit metadata_received(id)
    end

    return nil
  end

  private
  def listen_status(status)
    old_status = if @playback_status.nil? then -1 else @playback_status end
    @playback_status = status.value
    emit status_updated(old_status, @playback_status)
  end

  def listen_position(pos)
    old_pos = if @playlist_position.nil? then -1 else @playlist_position end
    @playlist_position = pos.value
    emit position_updated(old_pos, @playlist_position)
  end

  def listen_playlist_entries(entries)
    @playlist_entries = entries.value
    emit playlist_refreshed()
  end

  def listen_playlist_changes(res)
    # FIXME: check that desc[:name] == active
    desc = res.value
    case desc[:type]
    when Xmms::Playlist::ADD
      @playlist_entries.push(desc[:id])
      emit playlist_entry_inserted(desc[:id], @playlist_entries.size - 1)

    when Xmms::Playlist::INSERT
      @playlist_entries.insert(desc[:position], desc[:id])
      emit playlist_entry_inserted(desc[:id], desc[:position])

    when Xmms::Playlist::REMOVE
      @playlist_entries.delete_at(desc[:position])
      emit playlist_entry_removed(desc[:position])

    when Xmms::Playlist::MOVE
      @playlist_entries.delete_at(desc[:position])
      @playlist_entries.insert(desc[:newposition], desc[:id])
      emit playlist_entry_removed(desc[:position])
      emit playlist_entry_inserted(desc[:id], desc[:newposition])
      # FIXME: check that pos is correct

    when Xmms::Playlist::CLEAR
      @playlist_entries.clear
      emit playlist_refreshed()

    when Xmms::Playlist::UPDATE, Xmms::Playlist::SORT, Xmms::Playlist::SHUFFLE
      @xc.playlist.entries.notifier(&method(:listen_playlist_entries))
    else
      # FIXME: some kind of error <:o)
    end
  end
end


class Pane < Qt::Object

  # need to be redeclared in the child class!
  signals 'message(const QString&)', 'warning(const QString&)', 'error(const QString&)'

  # return the Qt::Widget of the pane, or nil if none
  def widget
    return nil
  end

  # execute the command
  def run(arguments, register_opts = nil)
    # FIXME: throw NotImplem
  end

  private
  def initialize()
    super()
  end
end


# sends simple commands to the xmms2 server, without any interface
class Control < Pane

  signals 'message(const QString&)', 'warning(const QString&)', 'error(const QString&)'

  def initialize(xc, cache)
    super()

    @xc = xc
    @cache = cache

    # init cache
    @cache.init_playback_status
  end

  def run(arguments, register_opts = nil)
    # FIXME: use arguments?

    case register_opts
    when :play
      @xc.playback_start
      emit message("Playback started.")

    when :pause
      @xc.playback_pause
      emit message("Playback paused.")

    when :stop
      @xc.playback_stop
      emit message("Playback stopped.")

    when :toggleplay
      if @cache.playback_status == Xmms::Client::PLAY
        @xc.playback_pause
        emit message("Playback paused.")
      else
        @xc.playback_start
        emit message("Playback started.")
      end

    else
      # FIXME: error?
    end
  end
end


class MediaItem < Qt::StandardItem

  MEDIA_ID_ROLE   = Qt::UserRole + 0
  READY_ROLE      = Qt::UserRole + 1
  CURRENT_ROLE    = Qt::UserRole + 2
  #FIXME: CURRENT_ROLE should be playlist-specific?

  def initialize(id)
    super()
    setData(Qt::Variant.new(id), MEDIA_ID_ROLE)
    setData(Qt::Variant.new(id), Qt::DisplayRole)
    setData(Qt::Variant.new(false), READY_ROLE)
    setEditable(false)

    self
  end

  def set_metadata(metadata)
    text = ""
    text += metadata[:artist] + " - " unless metadata[:artist].nil?
    text += metadata[:title] unless metadata[:title].nil?
    text = metadata[:url] if text.empty?
    setData(Qt::Variant.new(text), Qt::DisplayRole)
    setData(Qt::Variant.new(true), READY_ROLE)
  end

  def mid()
    return data(MediaItem::MEDIA_ID_ROLE).toUInt
  end

  def id()
    return mid
  end
end

class MediaItemModel < Qt::StandardItemModel

  slots 'update_metadata(int)'

  def initialize(cache)
    super()

    @cache = cache

    connect(@cache, SIGNAL('metadata_received(int)'), self, SLOT('update_metadata(int)'))

    self
  end

  def append_id(id)
    item = MediaItem.new(id)
    appendRow(item)
    item.set_metadata(@cache.fetch_mediainfos(id)) if @cache.has_mediainfos?(id)
  end

  def insert_id(pos, id)
    item = MediaItem.new(id)
    insertRow(pos, item)
    item.set_metadata(@cache.fetch_mediainfos(id)) if @cache.has_mediainfos?(id)
  end

  def remove_pos(pos)
    takeRow(pos)
  end

  def update_metadata(id)
    metadata = @cache.fetch_mediainfos(id)
    for i in 0...rowCount
      it = item(i)
      it.set_metadata(metadata) if it.mid == id
    end
  end

  def data(idx, role = Qt::DisplayRole)
    unless super(idx, MediaItem::READY_ROLE).toBool
      id = super(idx, MediaItem::MEDIA_ID_ROLE).toInt
      @cache.fetch_mediainfos(id)
    end

    super(idx, role)
  end
end

class MediaDelegate < Qt::ItemDelegate
  def initialize(parent)
    super(parent)
  end

  def paint(painter, option, index)
    # FIXME: Do something sexy later on instead
    curr = index.model.data(index, MediaItem::CURRENT_ROLE).toBool
    text = index.model.data(index, Qt::DisplayRole).toString

    painter.save
    font = option.font
    font.setBold(true) if curr
    painter.setFont(font)

    if parent.selectionModel.isSelected(index)
      painter.fillRect(option.rect, option.palette.highlight)
      painter.setPen(Qt::Color.new(Qt::white))
    end
    painter.drawText(option.rect, Qt::AlignLeft, text)
    painter.restore
#    super(painter, option, index)
  end
end


class Playlist < Pane

  slots 'activate(const QModelIndex &)', 'update_position(int, int)',
        'reset_playlist()', 'playlist_entry_insert(int, int)',
        'playlist_entry_remove(int)'

  def initialize(xc, cache)
    super()

    @xc = xc
    @cache = cache

    @filter_ids = nil

    @playlist = Qt::ListView.new
    @items = MediaItemModel.new(@cache)
    @deleg = MediaDelegate.new(@playlist)
    @playlist.setModel(@items)
    @playlist.setItemDelegate(@deleg)
    @playlist.setSelectionMode(Qt::AbstractItemView::ExtendedSelection)
    @playlist.setAlternatingRowColors(true)

    connect(@cache, SIGNAL('position_updated(int, int)'),
            self, SLOT('update_position(int, int)'))
    connect(@cache, SIGNAL('playlist_refreshed()'),
            self, SLOT('reset_playlist()'))
    connect(@cache, SIGNAL('playlist_entry_inserted(int, int)'),
            self, SLOT('playlist_entry_insert(int, int)'))
    connect(@cache, SIGNAL('playlist_entry_removed(int)'),
            self, SLOT('playlist_entry_remove(int)'))

    connect(@playlist, SIGNAL('activated(const QModelIndex &)'),
            self, SLOT('activate(const QModelIndex &)'))

    @cache.init_playlist_entries
    @cache.init_playlist_position
  end

  def widget
    return @playlist
  end

  def activate(item)
    @xc.playlist_set_next(item.row)
    @xc.playback_tickle
    @xc.playback_start unless @cache.playback_status == Xmms::Client::PLAY
  end

  def update_position(prev, new)
    if @items.hasIndex(prev, 0)
      @items.item(prev).setData(Qt::Variant.new(false), MediaItem::CURRENT_ROLE)
    end
    if @items.hasIndex(new, 0)
      @items.item(new).setData(Qt::Variant.new(true), MediaItem::CURRENT_ROLE)
    end
  end

  def reset_playlist()
    @items.clear
    @cache.playlist_entries.each {|id| @items.append_id(id)}
  end

  def playlist_entry_insert(id, pos)
    @items.insert_id(pos, id)
  end

  def playlist_entry_remove(pos)
    @items.remove_pos(pos)
  end

  def run(arguments, register_opts = nil)
    # FIXME: filter/reset should reread position
    if arguments.nil?
      # Reset filter
      @filter_ids = nil
      reset_playlist
    else
      # Filter playlist
      coll = Xmms::Collection.parse(arguments)
      @xc.coll_query_ids(coll) do |res|
        @filter_ids = res.value
        apply_filter
      end
    end
  end

  def apply_filter()
    # FIXME: ugly, suboptimal
    @items.clear
    (@cache.playlist_entries & @filter_ids).each do |id|
      @items.append_id(id)
    end
  end
end


class Search < Pane
  def initialize(xc, cache)
    super()

    @xc = xc
    @cache = cache

    @mlib = Qt::ListView.new
    @results = MediaItemModel.new(@cache)
    @mlib.setModel(@results)
    @mlib.setSelectionMode(Qt::AbstractItemView::ExtendedSelection)
    @mlib.setAlternatingRowColors(true)
  end

  def widget
    return @mlib
  end

  def run(arguments, register_opts = nil)
    # FIXME: show all?
    return if arguments.nil?

    coll = Xmms::Collection.parse(arguments)
    @xc.coll_query_ids(coll) do |res|
      @results.clear
      res.value.each {|id| @results.append_id(id)}
    end
  end
end


class Lindale < Qt::Widget

  class Command
    def initialize(target, opt)
      @target = target
      @option = opt
    end

    def has_widget?()
      return ! widget.nil?
    end

    def widget()
      return @target.widget
    end

    def run(args)
      @target.run(args, @option)
    end
  end


  slots 'run()', 'next_pane()', 'switch_focus()',
        'show_message(const QString&)', 'show_warning(const QString&)', 'show_error(const QString&)'

  def initialize()
    super()

    @status_bar_timeout = 2000

    @stack = Qt::StackedWidget.new
    @commands = Hash.new
    @panes = Array.new

    @cmd = Qt::LineEdit.new

    shortcut_tab = Qt::Shortcut.new(Qt::KeySequence.new("Tab"), self)
    shortcut_ctrltab = Qt::Shortcut.new(Qt::KeySequence.new("Ctrl+Tab"), self)
    shortcut_left = Qt::Shortcut.new(Qt::KeySequence.new("Ctrl+Left"), self)
    shortcut_right = Qt::Shortcut.new(Qt::KeySequence.new("Ctrl+Right"), self)

    connect(@cmd, SIGNAL('returnPressed()'), self, SLOT('run()'))

    connect(shortcut_tab, SIGNAL('activated()'), self, SLOT('switch_focus()'))
    connect(shortcut_ctrltab, SIGNAL('activated()'), self, SLOT('next_pane()'))
    connect(shortcut_left, SIGNAL('activated()'), self, SLOT('next_pane()'))
    connect(shortcut_right, SIGNAL('activated()'), self, SLOT('next_pane()'))

    layout = Qt::VBoxLayout.new
    layout.addWidget(@cmd)
    layout.addWidget(@stack)
    setLayout(layout)
  end

  def add_command(cmd, target, opt = nil)
    unless @panes.include?(target)
      # add widget to stack if exists
      unless target.widget.nil?
        @stack.addWidget(target.widget)
      end

      # connect status notifiers
      connect(target, SIGNAL('message(const QString&)'),
              self, SLOT('show_message(const QString&)'))
      connect(target, SIGNAL('warning(const QString&)'),
              self, SLOT('show_warning(const QString&)'))
      connect(target, SIGNAL('error(const QString&)'),
              self, SLOT('show_error(const QString&)'))
    end

    @commands[cmd] = Command.new(target, opt)
    @panes.push(target)
    self
  end

  def add_alias(cmd, *aliases)
    # FIXME: error unless @commands.key?(cmd)
    aliases.each do |alias_cmd|
      @commands[alias_cmd] = @commands[cmd]
    end
    self
  end

  def run()
    input = @cmd.text
    input.scan(/^(.*?)(?:\s+(.+)?)?$/) do ||
      cmd_str = $1
      command = @commands[cmd_str]

      if command.nil?
        show_error("invalid command: #{cmd_str}")
      else
        @stack.setCurrentWidget(command.widget) if command.has_widget?
        command.run($2)
      end
    end
  end

  def next_pane()
    newIndex = (@stack.currentIndex + 1) % @stack.count
    @stack.setCurrentIndex(newIndex)
  end

  def switch_focus()
    if @cmd.hasFocus
      @stack.currentWidget.setFocus(Qt::TabFocusReason)
    else
      @cmd.setFocus(Qt::TabFocusReason)
    end
  end

  def show_message(m)
    parent.statusBar.showMessage(m, @status_bar_timeout)
  end
  def show_warning(m)
    # FIXME: change background color
    parent.statusBar.showMessage(m, @status_bar_timeout)
  end
  def show_error(m)
    # FIXME: change background color
    parent.statusBar.showMessage(m, @status_bar_timeout)
  end
end




app = Qt::Application.new(ARGV)

xc = Xmms::Client::Async.new("lindale")
xc.connect(ENV["XMMS_PATH"])
xc.add_to_qt4_mainloop

cache = Xmms2Cache.new(xc)

# teh app
lindale = Lindale.new

# prepare panes
playlist = Playlist.new(xc, cache)
search = Search.new(xc, cache)
ctrl = Control.new(xc, cache)

# register commands
lindale.add_command('list', playlist)
lindale.add_command('search', search)
lindale.add_command('play', ctrl, :play)
lindale.add_command('pause', ctrl, :pause)
lindale.add_command('stop', ctrl, :stop)
lindale.add_command('p', ctrl, :toggleplay)
lindale.add_alias('search', 's', '?')


mainwin = Qt::MainWindow.new
mainwin.setCentralWidget(lindale)
mainwin.setWindowTitle("lindalë")
mainwin.show

app.exec()
