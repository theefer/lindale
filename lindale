#!/usr/bin/ruby

require 'Qt4'
require 'xmmsclient/async'

require './xmmsclient-qt4'


# TODO:
# - keep playlist up-to-date wrt updates (complete cache, signals)
# - use columns to separate fields
# - type in playlist to filter playlist entries (custom search)
# - actions should report a status message
# - share cache module variables among panes
# - reuse search results (activate to play, enqueue, copy, etc)


class Xmms2Cache < Qt::Object

  signals 'metadata_received(int)'

  def initialize(conn)
    super()

    @xc = conn
  end

  def init_playback_status()
    unless defined?(@playback_status)
      @playback_status = nil
      @xc.playback_status.notifier(&method(:listen_status))
      @xc.broadcast_playback_status.notifier(&method(:listen_status))
    end
  end

  def has_mediainfos?(id)
    @mediainfos = Hash.new unless defined?(@mediainfos)
    return @mediainfos.key?(id)
  end

  def fetch_mediainfos(id)
    return @mediainfos[id] if has_mediainfos?(id)

    @mediainfos[id] = nil
    @xc.medialib_get_info(id) do |dict|
      @mediainfos[id] = dict.value
      emit metadata_received(id)
    end

    return nil
  end

  private
  def listen_status(status)
    @playback_status = status.value
  end    
end


class Pane
  # return the Qt::Widget of the pane, or nil if none
  def widget
    return nil
  end

  # execute the command
  def run(arguments, register_opts = nil)
    # FIXME: throw NotImplem
  end

  private
  def initialize()
  end

  def message(m)
  end
end


# sends simple commands to the xmms2 server, without any interface
class Control < Pane

  def initialize(xc, cache)
    super()

    @xc = xc
    @cache = cache

    # init cache
    @cache.init_playback_status
    @cache.init_playback_status
  end

  def run(arguments, register_opts = nil)
    # FIXME: use arguments?

    case register_opts
    when :play
      @xc.playback_start

    when :pause
      @xc.playback_pause

    when :stop
      @xc.playback_stop

    when :toggleplay
      if @cache.playback_status == Xmms::Client::PLAY
        @xc.playback_pause
      else
        @xc.playback_start
      end

    else
      # FIXME: error?
    end
  end
end


class MediaItem < Qt::StandardItem

  MEDIA_ID_ROLE   = Qt::UserRole + 0
  READY_ROLE      = Qt::UserRole + 1

  def initialize(id)
    super()
    setData(Qt::Variant.new(id), MEDIA_ID_ROLE)
    setData(Qt::Variant.new(id), Qt::DisplayRole)
    setData(Qt::Variant.new(false), READY_ROLE)
    setEditable(false)

    self
  end

  def set_metadata(metadata)
    text = ""
    text += metadata[:artist] + " - " unless metadata[:artist].nil?
    text += metadata[:title] unless metadata[:title].nil?
    text = metadata[:url] if text.empty?
    setData(Qt::Variant.new(text), Qt::DisplayRole)
    setData(Qt::Variant.new(true), READY_ROLE)
  end

  def mid()
    return data(MediaItem::MEDIA_ID_ROLE).toUInt
  end

  def id()
    return mid
  end
end

class MediaItemModel < Qt::StandardItemModel

  slots 'update_metadata(int)'

  def initialize(cache)
    super()

    @cache = cache

    connect(@cache, SIGNAL('metadata_received(int)'), self, SLOT('update_metadata(int)'))

    self
  end

  def append_id(id)
    item = MediaItem.new(id)
    appendRow(item)
    item.set_metadata(@cache.fetch_mediainfos(id)) if @cache.has_mediainfos?(id)
  end

  def update_metadata(id)
    metadata = @cache.fetch_mediainfos(id)
    for i in 0...rowCount
      it = item(i)
      it.set_metadata(metadata) if it.mid == id
    end
  end

  def data(idx, role = Qt::DisplayRole)
    unless super(idx, MediaItem::READY_ROLE).toBool
      id = super(idx, MediaItem::MEDIA_ID_ROLE).toInt
      @cache.fetch_mediainfos(id)
    end

    super(idx, role)
  end
end


class Playlist < Pane
  def initialize(xc, cache)
    super()

    @xc = xc

    # FIXME: needs cache
  end

  def run(arguments, register_opts = nil)
    # FIXME: filter playlist
  end
end


class Search < Pane
  def initialize(xc, cache)
    super()

    @xc = xc
    @cache = cache

    @mlib = Qt::ListView.new
    @results = MediaItemModel.new(@cache)
    @mlib.setModel(@results)
    @mlib.setSelectionMode(Qt::AbstractItemView::ExtendedSelection)
    @mlib.setAlternatingRowColors(true)
  end

  def widget
    return @mlib
  end

  def run(arguments, register_opts = nil)
    coll = Xmms::Collection.parse(arguments)
    @xc.coll_query_ids(coll) do |res|
      @results.clear
      res.value.each {|id| @results.append_id(id)}
    end
  end
end


class Lindale < Qt::Widget

  class Command
    def initialize(target, opt)
      @target = target
      @option = opt
    end

    def run(args)
      @target.run(args, @option)
    end
  end


  slots 'run()', 'next_pane()', 'switch_focus()'

  def initialize()
    super()

    @stack = Qt::StackedWidget.new
    @commands = Hash.new

    @cmd = Qt::LineEdit.new

    shortcut_tab = Qt::Shortcut.new(Qt::KeySequence.new("Tab"), self)
    shortcut_ctrltab = Qt::Shortcut.new(Qt::KeySequence.new("Ctrl+Tab"), self)
    shortcut_left = Qt::Shortcut.new(Qt::KeySequence.new("Ctrl+Left"), self)
    shortcut_right = Qt::Shortcut.new(Qt::KeySequence.new("Ctrl+Right"), self)

    connect(@cmd, SIGNAL('returnPressed()'), self, SLOT('run()'))

    connect(shortcut_tab, SIGNAL('activated()'), self, SLOT('switch_focus()'))
    connect(shortcut_ctrltab, SIGNAL('activated()'), self, SLOT('next_pane()'))
    connect(shortcut_left, SIGNAL('activated()'), self, SLOT('next_pane()'))
    connect(shortcut_right, SIGNAL('activated()'), self, SLOT('next_pane()'))

    layout = Qt::VBoxLayout.new
    layout.addWidget(@cmd)
    layout.addWidget(@stack)
    setLayout(layout)
  end

  def add_command(cmd, target, opt = nil)
    unless target.widget.nil? or @stack.indexOf(target.widget) != -1
      @stack.addWidget(target.widget)
    end

    @commands[cmd] = Command.new(target, opt)
    self
  end

  def add_alias(cmd, *aliases)
    # FIXME: error unless @commands.key?(cmd)
    aliases.each do |alias_cmd|
      @commands[alias_cmd] = @commands[cmd]
    end
    self
  end

  def run()
    input = @cmd.text
    input.scan(/^(.*?)(?:\s+(.+))?$/) do ||
      cmd_str = $1
      command = @commands[cmd_str]

      if command.nil?
        puts "invalid command: " + cmd_str
      else
        command.run($2)
      end
    end
  end

  def next_pane()
    newIndex = (@stack.currentIndex + 1) % @stack.count
    @stack.setCurrentIndex(newIndex)
  end

  def switch_focus()
    if @cmd.hasFocus
      @stack.currentWidget.setFocus(Qt::TabFocusReason)
    else
      @cmd.setFocus(Qt::TabFocusReason)
    end
  end
end




app = Qt::Application.new(ARGV)

xc = Xmms::Client::Async.new("lindale")
xc.connect(ENV["XMMS_PATH"])
xc.add_to_qt4_mainloop

cache = Xmms2Cache.new(xc)

# teh app
lindale = Lindale.new

# prepare panes
ctrl = Control.new(xc, cache)
search = Search.new(xc, cache)
playlist = Playlist.new(xc, cache)

# register commands
lindale.add_command('search', search)
lindale.add_command('list', playlist)
lindale.add_command('play', ctrl, :play)
lindale.add_command('pause', ctrl, :pause)
lindale.add_command('stop', ctrl, :stop)
lindale.add_command('p', ctrl, :toggleplay)
lindale.add_alias('search', 's', '?')


mainwin = Qt::MainWindow.new
mainwin.setCentralWidget(lindale)
mainwin.setWindowTitle("lindalÃ«")
sb = mainwin.statusBar
mainwin.show

app.exec()
